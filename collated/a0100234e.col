//@author: a0100234e



	/**
	 * origin: D:\Workspace\CS2103T NEW\src\dothings\logic\Feedback.java
	 */

public class Feedback {
	private String description;
	private ArrayList<Integer> indexList;
	private boolean exit;
	private boolean error;
	
	/**
	 * Constructs and initializes a feedback object with the specified description.
	 * @param desc the description of the new feedback object.
	 */
	protected Feedback(String desc) {
		description = desc;
		error = false;
		exit = false;
		indexList = TaskHandler.getListOfTaskWithStatus(false);
	}
	
	/**
	 * Constructs and initializes a feedback object with an error status and a description of the error.
	 * @param desc the description of the new feedback object.
	 * @param isError true if the feedback object is an error message; false otherwise.
	 */
	protected Feedback(String desc, boolean isError) {
		description = desc;
		error = isError;
		exit = false;
		indexList = TaskHandler.getListOfTaskWithStatus(false);
	}
	
	/**
	 * Constructs and initializes a feedback object with an error status, exit flag, and its description.
	 * @param desc the description of the new feedback object.
	 * @param isError true if the feedback object is an error message; false otherwise.
	 * @param isExit true if the feedback object is an exit message; false otherwise.
	 */
	protected Feedback(String desc, boolean isError, boolean isExit) {
		description = desc;
		error = isError;
		exit = isExit;
		indexList = null;
	}
	
	/**
	 * Constructs and initializes a feedback object with a list of tasks to be displayed.
	 * @param desc the description of the new feedback object.
	 * @param list the index list of tasks to be displayed.
	 */
	protected Feedback(String desc, ArrayList<Integer> list) {
		description = desc;
		error = false;
		exit = false;
		indexList = list;
	}
	
	/**
	 * Returns the description of this feedback object.
	 * @return the description of this feedback object.
	 */
	protected String getDesc() {
		return description;
	}
	
	/**
	 * Returns the exit flag of this feedback object.
	 * @return the exit flag of this feedback object.
	 */
	protected boolean getExitFlag() {
		return exit;
	}
	
	/**
	 * Returns the index list of this feedback object.
	 * @return the index list of this feedback object.
	 */
	protected ArrayList<Integer> getIndexList() {
		return indexList;
	}
	
	/**
	 * Returns the error flag of this feedback object.
	 * @return the error flag of this feedback object.
	 */
	protected boolean getErrorFlag() {
		return error;
	}
	
	/**
	 * Sets the description of this task to the specified description.
	 * @param desc the specified description.
	 */
	protected void setDescription(String desc) {
		description = desc;
	}
	
	@Override
	/**
	 * Returns the string representation of this feedback object.
	 * @return the description of this feedback object.
	 */
	public String toString(){
		return description;
	}
	
	/**
	 * Checks whether this feedback object is the same as the specified feedback object.
	 * @param other the feedback object to be compared.
	 * @return true if this feedback object is the same as the specified feedback object.
	 */
	protected boolean equals(Feedback other){
		if (!description.equals(other.getDesc())) {
			return false;
		}
		if (exit != other.getExitFlag()) {
			return false;
		}
		if (error != other.getErrorFlag()) {
			return false;
		}
		if (indexList.equals(other.getIndexList())) {
			return false;
		}
		
		return true;
		
	}
}

	// End of segment: D:\Workspace\CS2103T NEW\src\dothings\logic\Feedback.java





	/**
	 * origin: D:\Workspace\CS2103T NEW\src\dothings\logic\Task.java
	 */

public class Task implements Comparable<Task>{
	private static final String LOG_SAVING_TASK_LIST = "Saving task list.";

	private static final String LOG_LOADING_TASK_LIST = "Loading task list.";

	private static final String FILE_TASK = "tasks.txt";

	public static final int START_DATE = 0;
	public static final int START_TIME = 1;
	public static final int END_DATE = 2;
	public static final int END_TIME = 3;
	public static final int TASK_FIELD_SIZE = 4;

	private static final String DELIMITER = " ~~ ";
	private static final String NULL_START = "NO_START_TIME";
	private static final String NULL_END = "NO_END_TIME";
	private static final String NULL_ALIAS = "NO_ALIAS";
	private static final String DATE_DISPLAY_FORMAT_1 = "%s %s to %s %s";
	private static final String DATE_DISPLAY_FORMAT_2 = "%s %s";

	private static ArrayList<Task> taskList = loadTasks();

	private DateTime startDateTime;
	private DateTime endDateTime;
	private String description;
	private boolean status;
	private String alias;

	/**
	 * Constructs and initializes a task with the specified description.
	 * @param desc the description of the new task object.
	 */
	public Task(String desc) {
		description = desc;
		status = false;
	}

	/**
	 * Constructs and initializes a task with the same fields as the input task object.
	 * @param task the input task object.
	 */
	public Task(Task task) {
		startDateTime = task.startDateTime;
		endDateTime = task.endDateTime;
		status = task.status;
		description = task.description;
		alias = task.alias;
	}

	/**
	 * Constructs and initializes a new task with the specified fields above.
	 * @param desc the description of the new task object.
	 * @param start the start time of the new task object.
	 * @param end the end time of the new task object.
	 * @param name the name of the new task object.
	 */
	public Task(String desc, DateTime start, DateTime end, String name) {
		startDateTime = start;
		endDateTime = end;
		status = false;
		description = desc;
		alias = name;
	}
	
	/**
	 * Constructs and initializes a new task with the specified fields above.
	 * @param desc the description of the new task object.
	 * @param start the start time of the new task object.
	 * @param end the end time of the new task object.
	 * @param name the name of the new task object.
	 * @param stat the status of the task, whether it is marked as complete or not.
	 */
	public Task(String desc, DateTime start, DateTime end, String name, boolean stat) {
		startDateTime = start;
		endDateTime = end;
		status = stat;
		description = desc;
		alias = name;
	}
	
	/**
	 * Sets the description of this task to the specified description.
	 * @param desc the specified description.
	 */
	public void setDescription(String desc) {
		description = desc;
	}
	
	/**
	 * Sets the start time of this task to the specified time.
	 * @param start the specified start time.
	 */
	public void setStartDateTime(DateTime start) {
		startDateTime = start;
	}
	
	/**
	 * Sets the end time of this task to to the specified time.
	 * @param end the specified end time.
	 */
	public void setEndDateTime(DateTime end) {
		endDateTime = end; 
	}
	
	/**
	 * Toggles the status of this task.
	 */
	public void toggleStatus() {
		status = !status;
	}
	
	/**
	 * Sets the alias of this task to the specified alias.
	 * @param alias
	 */
	public void setAlias(String alias) {	
		this.alias = alias;
	}
	
	/**
	 * Returns the description of this task.
	 * @return the description of this task.
	 */
	public String getDescription() {
		return description;
	}
	
	/**
	 * Returns the start time of this task.
	 * @return the start time of this task.
	 */
	public DateTime getStartDateTime() {
		return startDateTime;
	}
	
	/**
	 * Returns the end time of this task.
	 * @return the end time of this task.
	 */
	public DateTime getEndDateTime() {
		return endDateTime;
	}
	
	/**
	 * Returns the status of this task.
	 * @return true if this task is marked as complete; false otherwise.
	 */
	public boolean getStatus() {
		return status;
	}
	
	/**
	 * Returns the alias of this task.
	 * @return the alias of this task.
	 */
	public String getAlias() {
		return alias;
	}
	/**
	 * Returns the entire list of tasks.
	 * @return the entire list of tasks.
	 */
	public static ArrayList<Task> getList() {
		return taskList;
	}
	
	public static ArrayList<Task> getCloneList() {
		ArrayList<Task> clone = new ArrayList<Task>();
		for (int i = 0; i < taskList.size(); i++) {
			clone.add(new Task(taskList.get(i)));
		}
		
		return clone;
	}
	
	/**
	 * Replaces the current task list with the specified task list.
	 * @param list
	 */
	public static void setList(ArrayList<Task> list) {
		taskList = list;
	}
	
	/**
	 * Sorts the task list.
	 */
	public static void sortList() {
		Collections.sort(taskList);
	}	
	/**
	 * Checks whether this task is overdue.
	 * @return true if this task is overdue; false otherwise.
	 */
	public boolean isOverdue() {
		if (endDateTime != null) {
			return endDateTime.isBeforeNow();
		} else if (startDateTime != null) {
			return startDateTime.isBeforeNow();
		}

		return false;
	}
	/**
	 * Checks whether this task is due today.
	 * @return true if this task is due today; false otherwise.
	 */
	public boolean isToday() {
		DateTime today = (new DateTime()).withTimeAtStartOfDay();
		if (startDateTime != null) {
			return today.equals(startDateTime.withTimeAtStartOfDay());
		} else if (endDateTime != null) {
			return today.equals(endDateTime.withTimeAtStartOfDay());
		}

		return false;
	}
	/**
	 * Checks whether this task has no schedule.
	 * @return true if this task has no schedule; false otherwise;
	 */
	public boolean isUnscheduled() {
		return startDateTime == null && endDateTime == null;
	}
	/**
	 * Separates the different parameters from the input
	 * @param line a string input to be separated.
	 * @return a new task object with the specified fields.
	 */
	public static Task parseTaskFromString(String line) {
		String[] tokens = line.split(DELIMITER);
		DateTime start = (tokens[0].equals(NULL_START)) ? null : new DateTime(tokens[0]);
		DateTime end = (tokens[1].equals(NULL_END)) ? null : new DateTime(tokens[1]);
		String name = (tokens[2].equals(NULL_ALIAS)) ? null : tokens[2]; 
		boolean stat = (tokens[3].equals("true")) ? true : false;
		String desc = tokens[4];

		return new Task(desc, start, end, name , stat);
	}

	@Override
	/**
	 * Returns the string representation of the task.
	 * @return the string representation of the task.
	 */
	public String toString() {
		String start = (startDateTime == null) ? NULL_START : startDateTime.toString();
		String end = (endDateTime == null) ? NULL_END : endDateTime.toString();
		String taskAlias = (alias == null) ? NULL_ALIAS : alias;

		return start + DELIMITER + end + DELIMITER + taskAlias + DELIMITER + status + DELIMITER + description;
	}
	/**
	 * Returns the start and end time of this task.
	 * @return the start and end time of this task.
	 */
	public String getDateTimeString() {
		if (startDateTime != null && endDateTime != null) {
			return String.format(DATE_DISPLAY_FORMAT_1, getDateString(startDateTime), getTimeString(startDateTime), getDateString(endDateTime), getTimeString(endDateTime));
		} else if (startDateTime != null) {
			return String.format(DATE_DISPLAY_FORMAT_2, getDateString(startDateTime), getTimeString(startDateTime));
		} else if (endDateTime != null) {
			return String.format(DATE_DISPLAY_FORMAT_2, getDateString(endDateTime), getTimeString(endDateTime));
		} else {
			return "";
		}
	}
	/**
	 * Obtains the time from the specified DateTime object.
	 * @param date the specified DateTime object.
	 * @return the time portion of the specified DateTime object.
	 */
	public static String getTimeString(DateTime date) {
		if (date == null) {
			return null;
		}

		DecimalFormat df = new DecimalFormat("00");
		String time = df.format(date.getHourOfDay()) + ":" + df.format(date.getMinuteOfHour());
		return time;
	}
	/**
	 * Obtains the date from the specified DateTime object.
	 * @param date
	 * @return the date portion of the specified DateTime object.
	 */
	public static String getDateString(DateTime date) {
		if (date == null) {
			return null;
		}

		return date.toString("dd MMM YYYY");
	}

	@Override
	/**
	 * Checks whether this task's time is before or after the specified task's time.
	 * @param task an object to be compared with this task.
	 */
	public int compareTo(Task task) {
		if (this.startDateTime != null && task.startDateTime != null) {
			return this.startDateTime.compareTo(task.startDateTime);

		} else if (this.startDateTime == null && task.startDateTime != null) {
			if(this.endDateTime != null) {
				return this.endDateTime.compareTo(task.startDateTime);
			}
			return 1;

		} else if (this.startDateTime != null && task.startDateTime == null) {
			if(task.endDateTime != null) {
				return this.startDateTime.compareTo(task.endDateTime);
			}
			return -1;

		} else {
			if (this.endDateTime == null && task.endDateTime == null) {
				return this.description.compareToIgnoreCase(task.description);
			} else if (this.endDateTime != null && task.endDateTime == null) {
				return -1;
			} else if (this.endDateTime == null && task.endDateTime != null) {
				return 1;
			} else {
				return this.endDateTime.compareTo(task.endDateTime);
			}
		}
	}

	/**
	 * Checks whether the specified string is a valid alias.
	 * @param alias the string to be checked.
	 * @return true if the alias is valid; false otherwise.
	 */
	public static boolean isAliasValid(String alias) {
		if (alias == null || alias.length() == 0 || alias.equals("")) {
			return false;
		}

		if (getTaskIndexFromAlias(alias) < 0) {
			return false;
		}
		if (alias.equalsIgnoreCase("completed") || alias.equalsIgnoreCase("all")) {
			return false;
		}


		return true;
	}
	/**
	 * Obtains the task index from the specified string.
	 * @param alias the string from which the task index is retrieved.
	 * @return the task index; -1 otherwise.
	 */
	public static int getTaskIndexFromAlias(String alias) {
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getAlias() == null) {
				continue;
			}
			if (alias.equals(taskList.get(i).getAlias())) {
				return i;
			}
		}

		return -1;
	}
	/**
	 * Saves the task list to text file.
	 */
	public static void saveTasks() {
		FileManager.log(LOG_SAVING_TASK_LIST);
		ArrayList<String> listToSave = new ArrayList<String>();
		for (int i = 0; i < taskList.size(); i++) {
			String taskStringForm = taskList.get(i).toString();
			listToSave.add(taskStringForm);
		}

		FileManager.writeToFile(FILE_TASK, listToSave);
	}
	/**
	 * Loads the task list from the text file.
	 * @return the task list. 
	 */
	public static ArrayList<Task> loadTasks() {
		FileManager.log(LOG_LOADING_TASK_LIST);
		ArrayList<Task> listOfTasks = new ArrayList<Task>();
		ArrayList<String> list = FileManager.readFromFile(FILE_TASK);

		for (int i = 0; i < list.size(); i++) {
			String line = list.get(i);
			listOfTasks.add(parseTaskFromString(line));
		}

		return listOfTasks;
	}
}
	// End of segment: D:\Workspace\CS2103T NEW\src\dothings\logic\Task.java





	/**
	 * origin: D:\Workspace\CS2103T NEW\src\dothings\logic\TaskHandler.java
	 */

	//////////UPDATE Functionality//////////
	/**
	 * Updates a task in the specified field
	 * Input format is [task number/alias][field to update][update]
	 * @param update
	 * @return a Feedback object to be shown to the user
	 */
	protected static Feedback updateTask(String update) {	
		if (!CommandParser.isInputValid(update, 2)) {
			return new Feedback(MESSAGE_ERROR_UPDATE_ARGUMENT);
		}
		
		String taskID = CommandParser.getUserCommandType(update);
		String updateStringWithoutID = CommandParser.getUserCommandDesc(update);
		String updateField = CommandParser.getUserCommandType(updateStringWithoutID);
		String updateDesc = CommandParser.getUserCommandDesc(updateStringWithoutID);
		
		Task taskToUpdate = null;
		int updateIndex = getIndexToUpdate(taskID);
		
		if (updateIndex == -1) {
			return new Feedback(MESSAGE_ERROR_UPDATE_NO_SUCH_TASK, true);
		}
		
		if (updateField.equalsIgnoreCase(UPDATE_FIELD_START) || updateField.equalsIgnoreCase(UPDATE_FIELD_END) || updateField.equalsIgnoreCase(UPDATE_FIELD_TIME)) {
			if (!CommandParser.isInputValid(updateDesc, 1)) {
				return new Feedback(MESSAGE_ERROR_UPDATE_ARGUMENT, true);
			}
			
			taskToUpdate = new Task(Task.getList().get(updateIndex));
			taskToUpdate = updateTaskTime(taskToUpdate, updateField, updateDesc);
			
			if (taskToUpdate == null) {
				return new Feedback(MESSAGE_ERROR_START_AFTER_END, true);
			}
			
		} else if (updateField.equals(UPDATE_FIELD_ALIAS)) {
			String[] tokens = updateDesc.split(WHITESPACE);
			if (tokens.length <= 0) {
				return new Feedback(MESSAGE_ERROR_ALIAS, true);
			}

			String alias = tokens[0];	
			if (Task.isAliasValid(alias) || CommandParser.isInteger(alias)) {
				return new Feedback(MESSAGE_ERROR_ALIAS_IN_USE, true);
			
			}
			
			taskToUpdate = new Task(Task.getList().get(updateIndex));
			taskToUpdate.setAlias(alias);
			
		} else if (updateField.equals(UPDATE_FIELD_DESC1) || updateField.equals(UPDATE_FIELD_DESC2)) {
			if (!CommandParser.isInputValid(updateDesc, 1)) {
				return new Feedback(MESSAGE_ERROR_UPDATE_ARGUMENT, true);
			}
			
			taskToUpdate = new Task(Task.getList().get(updateIndex));
			taskToUpdate.setDescription(updateDesc);
			
		} else {
			taskToUpdate = createTask(updateStringWithoutID);
			
			if (taskToUpdate.getDescription().trim().length() == 0) {
				return new Feedback(MESSAGE_ERROR_TASK_DESC_EMPTY, true);
			}
		}
		
		HistoryHandler.pushUndoStack();
		Task.getList().remove(updateIndex);
		Task.getList().add(taskToUpdate);
		executePostCommandRoutine();
		return new Feedback(MESSAGE_UPDATE_TASK);
	}
	
	/**
	 * Toggles the status of the specified tasks.
	 * @param taskID
	 * @return Feedback object containing the information to be shown to the user.
	 */
	protected static Feedback markTask(String taskID) {
		ArrayList<Integer> listToMark = getTaskIdFromString(taskID);
		if(listToMark.size() == 0) {
			return new Feedback(MESSAGE_ERROR_MARK_NO_TASK, true);
		}
		
		ArrayList<Task> taskList = Task.getCloneList();
		for (int i = 0; i < listToMark.size(); i++) {
			taskList.get((int)listToMark.get(i)).toggleStatus();
		}
		
		HistoryHandler.pushUndoStack();
		Task.setList(taskList);
		executePostCommandRoutine();
		return new Feedback(MESSAGE_TASK_MARK);
	}
	
	/**
	 * Updates the time of the input task
	 * @param task
	 * @param field
	 * @param update
	 * @return the updated task
	 */
	private static Task updateTaskTime(Task task, String field, String update) {
		assert(field.equalsIgnoreCase(UPDATE_FIELD_TIME) || field.equalsIgnoreCase(UPDATE_FIELD_START) || field.equalsIgnoreCase(UPDATE_FIELD_END));
		
		ArrayList<String> updateTokens = new ArrayList<String>(Arrays.asList(update.split(WHITESPACE)));
		String[] timeFields = CommandParser.getTaskFields(updateTokens);
		
		if (field.equalsIgnoreCase(UPDATE_FIELD_TIME)) {
			Task tempTask = createTask(update);
			if (tempTask == null) {
				return null;
			}
			task.setStartDateTime(tempTask.getStartDateTime());
			task.setEndDateTime(tempTask.getEndDateTime());
		} else {
			DateTime dateTime = task.getStartDateTime();
			String date = timeFields[Task.START_DATE];
			String time = timeFields[Task.START_TIME];
			
			if (date != null && time != null) {
				dateTime = DateParser.setDate(date);
				dateTime = TimeParser.setTime(dateTime, time);
			} else if (date != null) {
				DateTime temp = DateParser.setDate(date);
				dateTime = TimeParser.setTime(temp, Task.getTimeString(dateTime));
			} else if (time != null) {
				dateTime = TimeParser.setTime(dateTime, time);
			} else {
				return null;
			}
			
			if (field.equalsIgnoreCase(UPDATE_FIELD_START)) {
				task.setStartDateTime(dateTime);
			} else {
				task.setEndDateTime(dateTime);
			}
			
			if (task.getStartDateTime().isAfter(task.getEndDateTime())) {
				return null;
			}
		}
		
		return task;
	}
	
	/**
	 * Get the index of the task from the taskID
	 * @param taskID
	 * @return
	 */
	private static int getIndexToUpdate(String taskID) {
		int index = -1;
		
		if (CommandParser.isInteger(taskID)) {
			index = Integer.parseInt(taskID) - 1;
		} else if (Task.isAliasValid(taskID)) {
			index = Task.getTaskIndexFromAlias(taskID);
		}
		
		if (index < 0 || index >= Task.getList().size()) {
			return -1;
		}
		
		return index;
	}
	
	// End of segment: D:\Workspace\CS2103T NEW\src\dothings\logic\TaskHandler.java





	/**
	 * origin: D:\Workspace\CS2103T NEW\src\dothings\logic\TaskHandler.java
	 */

	////////////////SEARCH Functionality////////////////////
	/**
	 * Returns the indices of tasks that contain at least one the words.
	 * @param searchKey
	 * @return ArrayList of task indices
	 */
	protected static Feedback searchTasks(String searchKey) {
		String[] keys = searchKey.split(WHITESPACE);
		if (keys.length == 0) {
			return new Feedback(MESSAGE_ERROR_SEARCH);
		}
		ArrayList<Task> taskList = Task.getList();
		ArrayList<Integer> indexList = new ArrayList<Integer>();
		
		for (int i = 0; i < taskList.size(); i++) {
			for (int j = 0; j < keys.length; j++) {
				if (taskList.get(i).getDescription().toLowerCase().contains(keys[j].toLowerCase())) {
					indexList.add(i);
					break;
				}
			}
		}
		
		return new Feedback("Search for " + searchKey , indexList);
	}
	
	/**
	 * Executes the necessary methods after a user operation on the task list
	 */
	private static void executePostCommandRoutine() {
		Task.sortList();
		Task.saveTasks();
		HistoryHandler.purgeRedoStack();
	}
}
	// End of segment: D:\Workspace\CS2103T NEW\src\dothings\logic\TaskHandler.java





